import pandas as pd
import requests as req

from classes.base_data import BaseData
from constants.constants import DATA_ROOT, PREDIRECTIONALS, Geocodio
from constants.constants import Geocodio as gcd
from constants.landlord_fields import LandlordFields

class BaseGeocodio(BaseData):

    WKFL_VALIDATED_MASTER = f"{DATA_ROOT}/landlord_workflow/wkfl_validated_master.csv"
    WKFL_UNVALIDATED_MASTER = f"{DATA_ROOT}/landlord_workflow/wkfl_unvalidated_master.csv"

    ps = LandlordFields.PropertyScrapeFields
    va = LandlordFields.ValidatedAddressFields

    def __init__(self):
        super().__init__()

    @classmethod
    def fetch_unanalyzed_addrs(cls, df_scrape_addrs):

        """
        Accepts dataframe of scraped properties as a parameter. Return a subset of the dataframe passed as a parameter
        for rows whose addresses stored in the RAW_ADDRESS column are NOT found in the master lists of analyzed
        addresses, pulled from the validated_master and unvalidated_master datasets generated by the landlord data
        workflow.
        """

        # fetch all addresses previously run through geocodio
        df_addrs_validated = cls.get_df(cls.WKFL_VALIDATED_MASTER, cls.va.DTYPES)
        df_addrs_unvalidated = cls.get_df(cls.WKFL_UNVALIDATED_MASTER, cls.va.DTYPES)

        # merge into unique list
        analyzed = list(df_addrs_validated[cls.ps.RAW_ADDRESS].unique()) + list(df_addrs_unvalidated[cls.ps.RAW_ADDRESS].unique())
        df_analyzed = pd.DataFrame(analyzed, columns=[cls.ps.RAW_ADDRESS])
        addrs_analyzed = list(df_analyzed[cls.ps.RAW_ADDRESS].unique())

        # subset inputted dataframe by raw addresses that do NOT appear in the list of already analyzed addresses
        df_unanalyzed = df_scrape_addrs[~df_scrape_addrs[cls.ps.RAW_ADDRESS].isin(addrs_analyzed)]
        df_unanalyzed_filtered = df_unanalyzed[df_unanalyzed[cls.ps.TAXPAYER_ADDRESS].notnull()]
        df_unanalyzed_filtered.drop_duplicates(cls.ps.RAW_ADDRESS, inplace=True)
        df_unanalyzed_filtered.dropna(subset=[cls.ps.RAW_ADDRESS], inplace=True)

        return df_unanalyzed_filtered

    @classmethod
    def save_partial_geocodio(cls, gcd_results):
        timestamp = cls.get_timestamp()
        df_partial = pd.DataFrame(gcd_results)
        partial_scrape_path = f"{DATA_ROOT}/geocodio/partials/partial_geocodio_({timestamp}).csv"
        cls.save_df(df_partial, partial_scrape_path, DATA_ROOT)

    # -------------------------------------
    # ----MAIN GEOCODIO CALLER FUNCTION----
    # -------------------------------------
    @classmethod
    def call_geocodio(cls, address_search_string):
        base_url = gcd.GEOCODIO_URL
        addr_cleaned = cls.remove_hash_char(address_search_string)
        final_url = base_url + addr_cleaned
        res = req.get(final_url)
        if res.status_code == 200:
            data = res.json()
            return data["results"]
        else:
            return None


class GeocodioTaxpayer(BaseGeocodio):

    def __init__(self):
        super().__init__()

    # --------------------------------
    # ----PROCESS API CALL RESULTS----
    # --------------------------------
    @classmethod
    def process_results(cls, row, result):
        """
        Creates row for each unique combination of geocodio result and raw taxpayer data. For example, if a single
        taxpayer address returns 5 geocodio results, this function will be run 5 times and return 5 rows, of which will
        contain identical raw taxpayer data but unique geocodio results.
        """
        address_components = result.get("address_components", {})
        location = result.get("location", {})
        row = {
            cls.va.RAW_ADDRESS: row[cls.va.RAW_ADDRESS],
            cls.va.TAXPAYER_ADDRESS: row[cls.va.TAXPAYER_ADDRESS],
            cls.va.TAXPAYER_CITY: row[cls.va.TAXPAYER_CITY],
            cls.va.TAXPAYER_STATE: row[cls.va.TAXPAYER_STATE],
            cls.va.TAXPAYER_ZIP: row[cls.va.TAXPAYER_ZIP],
            cls.va.GEOCODIO_SUCCESS: True,
            cls.va.GCD_NUMBER: address_components.get("number", ""),
            cls.va.GCD_PREDIRECTIONAL: address_components.get("predirectional", ""),
            cls.va.GCD_PREFIX: address_components.get("prefix", ""),
            cls.va.GCD_STREET: address_components.get("street", ""),
            cls.va.GCD_SUFFIX: address_components.get("suffix", ""),
            cls.va.GCD_POSTDIRECTIONAL: address_components.get("postdirectional", ""),
            cls.va.GCD_SECONDARYUNIT: address_components.get("secondaryunit", ""),
            cls.va.GCD_SECONDARYNUMBER: address_components.get("secondarynumber", ""),
            cls.va.GCD_CITY: address_components.get("city", ""),
            cls.va.GCD_COUNTY: address_components.get("county", ""),
            cls.va.GCD_STATE: address_components.get("state", ""),
            cls.va.GCD_ZIP: address_components.get("zip", ""),
            cls.va.GCD_COUNTRY: address_components.get("country", ""),
            cls.va.GCD_XCOORD: location.get("lng", ""),
            cls.va.GCD_YCOORD: location.get("lat", ""),
            cls.va.GCD_ACCURACY: result.get("accuracy", ""),
            cls.va.GCD_FORMATTED_ADDRESS: result.get("formatted_address", "")
        }
        return row

    @classmethod
    def process_results_none(cls, row):
        """
        Handles cases where geocodio did NOT return results for the raw address passed into it.
        """
        row = {
            cls.va.RAW_ADDRESS: row[cls.va.RAW_ADDRESS],
            cls.va.TAXPAYER_ADDRESS: row[cls.va.TAXPAYER_ADDRESS],
            cls.va.TAXPAYER_CITY: row[cls.va.TAXPAYER_CITY],
            cls.va.TAXPAYER_STATE: row[cls.va.TAXPAYER_STATE],
            cls.va.TAXPAYER_ZIP: row[cls.va.TAXPAYER_ZIP],
            cls.va.GEOCODIO_SUCCESS: False,
            cls.va.GCD_NUMBER: "",
            cls.va.GCD_PREDIRECTIONAL: "",
            cls.va.GCD_PREFIX: "",
            cls.va.GCD_STREET: "",
            cls.va.GCD_SUFFIX: "",
            cls.va.GCD_POSTDIRECTIONAL: "",
            cls.va.GCD_SECONDARYUNIT: "",
            cls.va.GCD_SECONDARYNUMBER: "",
            cls.va.GCD_CITY: "",
            cls.va.GCD_COUNTY: "",
            cls.va.GCD_STATE: "",
            cls.va.GCD_ZIP: "",
            cls.va.GCD_COUNTRY: "",
            cls.va.GCD_XCOORD: "",
            cls.va.GCD_YCOORD: "",
            cls.va.GCD_ACCURACY: "",
            cls.va.GCD_FORMATTED_ADDRESS: ""
        }
        return row


class GeocodioCorpLLC(BaseGeocodio):

    def __init__(self):
        super().__init__()


class GeocodioResults(BaseGeocodio):

    def __init__(self):
        super().__init__()

    @classmethod
    def contains_predirectional(cls, raw_address, geocodio_predir_list):
        raw_address_split = raw_address.split(" ")
        # Replace fully spelled-out predirectionals with their abbreviations
        for full, abbr in PREDIRECTIONALS.items():
            if full in raw_address_split:
                raw_address = raw_address.replace(full, abbr)
        # Now check if any of the abbreviations are in the geocodio result
        return any(abbr in raw_address for abbr in geocodio_predir_list)

    @classmethod
    def check_matching_addrs(cls, df):
        formatted_addrs = set(df[cls.va.GCD_FORMATTED_ADDRESS].tolist())
        return len(formatted_addrs) == 1

    @classmethod
    def process_address(cls, df_gcd_results, addr, validated_rows, unvalidated_rows, no_results):

        # Fetch only rows whose raw address matches "addr", clean data
        df = df_gcd_results[df_gcd_results[cls.va.RAW_ADDRESS] == addr]
        df = df.fillna("")
        df = df.map(lambda x: x.upper() if isinstance(x, str) else x)

        # Handle failed geocodio calls
        if not df.iloc[0][cls.va.GEOCODIO_SUCCESS]:
            no_results.append(df.iloc[0].to_dict())
            return

        # Handle results with empty street numbers
        df_street_no = df[df[cls.va.GCD_NUMBER] != ""]
        if df_street_no.empty:
            unvalidated_rows.extend(df.to_dict("records"))
            return

        if len(df_street_no) == 1 or cls.check_matching_addrs(df_street_no):
            validated_rows.append(df_street_no.iloc[0].to_dict())
            return

        # Apply filters
        cls.apply_filters(df_street_no, validated_rows, unvalidated_rows)

    @classmethod
    def apply_filters(cls, df, validated_rows, unvalidated_rows):

        # FILTER 1: street number
        # print("filtering street number...")
        addr_sc_split = df.iloc[0][cls.va.TAXPAYER_ADDRESS].split()
        number_sc = addr_sc_split[0]
        df_number = df[df[cls.va.GCD_NUMBER] == number_sc]
        if df_number.empty:
            unvalidated_rows.extend(df.to_dict("records"))
            return
        if len(df_number) == 1 or cls.check_matching_addrs(df_number):
            validated_rows.append(df_number.iloc[0].to_dict())
            return

        # FILTER 2: zip code
        # print("filtering zip code...")
        zip_sc = df_number.iloc[0][cls.va.TAXPAYER_ZIP]
        df_zip = df_number[df_number[cls.va.GCD_ZIP] == zip_sc]
        if df_zip.empty:
            unvalidated_rows.extend(df_number.to_dict("records"))
            return
        if len(df_zip) == 1 or cls.check_matching_addrs(df_zip):
            validated_rows.append(df_zip.iloc[0].to_dict())
            return

        # FILTER 3: street name
        # print("filtering street name...")
        streets = df_zip[cls.va.GCD_STREET].unique()
        df_street = pd.DataFrame()
        for street in streets:
            street_split = street.split()
            if all(word in addr_sc_split for word in street_split):
                df_street = df_zip[df_zip[cls.va.GCD_STREET] == street]
                break
        if df_street.empty:
            unvalidated_rows.extend(df_zip.to_dict("records"))
            return
        if len(df_street) == 1 or cls.check_matching_addrs(df_street):
            validated_rows.append(df_street.iloc[0].to_dict())
            return

        # FILTER 4: city name
        # print("filtering city name...")
        city_sc = df_street.iloc[0][cls.va.TAXPAYER_CITY]
        df_city = df_street[df_street[cls.va.TAXPAYER_CITY] == city_sc]
        if df_city.empty:
            unvalidated_rows.extend(df_street.to_dict("records"))
            return
        if len(df_city) == 1 or cls.check_matching_addrs(df_city):
            validated_rows.append(df_city.iloc[0].to_dict())
            return

        # FILTER 5: predirectional
        # print("filtering predirectional...")
        predirs = df_city[cls.va.GCD_PREDIRECTIONAL].unique().tolist()
        df_predir = df_city[df_city.apply(lambda row: cls.contains_predirectional(
            row[cls.va.TAXPAYER_ADDRESS],
            predirs
        ), axis=1)]
        if df_predir.empty:
            unvalidated_rows.extend(df_city.to_dict("records"))
            return
        if len(df_predir) == 1 or cls.check_matching_addrs(df_predir):
            validated_rows.append(df_predir.iloc[0].to_dict())
            return

        # FILTER 6: street suffix
        # print("filtering street suffix...")
        df_suffix = df_predir[df_predir[cls.va.GCD_SUFFIX].isin(addr_sc_split)]
        if df_suffix.empty:
            unvalidated_rows.extend(df_predir.to_dict("records"))
            return
        if len(df_suffix) == 1 or cls.check_matching_addrs(df_suffix):
            validated_rows.append(df_suffix.iloc[0].to_dict())
            return
        unvalidated_rows.extend(df_predir.to_dict("records"))

